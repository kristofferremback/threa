import type { Request, Response } from "express"
import type { AttachmentService } from "../services/attachment-service"
import type { StreamService } from "../services/stream-service"
import type { StreamType } from "@threa/types"
import { StreamTypes } from "@threa/types"

interface Dependencies {
  attachmentService: AttachmentService
  streamService: StreamService
}

export function createAttachmentHandlers({ attachmentService, streamService }: Dependencies) {
  return {
    async upload(req: Request, res: Response) {
      const userId = req.userId!
      const workspaceId = req.workspaceId!
      const { streamId } = req.params

      // Validate stream exists and user can access it
      const stream = await streamService.getStreamById(streamId)
      if (!stream || stream.workspaceId !== workspaceId) {
        return res.status(404).json({ error: "Stream not found" })
      }

      // Attachments can only be uploaded to top-level streams (channels, scratchpads, DMs).
      // Thread membership is implicit via root stream access, and threads may not exist yet at
      // upload time (created on first message). Files uploaded to a channel can be attached to
      // thread messages within that channel.
      const allowedStreamTypes: readonly StreamType[] = [StreamTypes.CHANNEL, StreamTypes.DM, StreamTypes.SCRATCHPAD]
      if (!allowedStreamTypes.includes(stream.type)) {
        return res.status(400).json({
          error: "Attachments must be uploaded to channels, DMs, or scratchpads",
        })
      }

      const isMember = await streamService.isMember(streamId, userId)
      if (!isMember) {
        return res.status(403).json({ error: "Not a member of this stream" })
      }

      // File was uploaded to S3 by multer-s3 middleware
      const file = req.file
      if (!file || !file.key) {
        return res.status(400).json({ error: "No file provided" })
      }

      // The attachment ID was generated by the upload middleware
      const attachmentId = req.attachmentId!

      const attachment = await attachmentService.create({
        id: attachmentId,
        workspaceId,
        streamId,
        filename: file.originalname,
        mimeType: file.mimetype,
        sizeBytes: file.size,
        storagePath: file.key,
      })

      res.status(201).json({ attachment })
    },

    async getDownloadUrl(req: Request, res: Response) {
      const userId = req.userId!
      const workspaceId = req.workspaceId!
      const { attachmentId } = req.params

      const attachment = await attachmentService.getById(attachmentId)
      if (!attachment || attachment.workspaceId !== workspaceId) {
        return res.status(404).json({ error: "Attachment not found" })
      }

      // Validate user has access to the stream
      const isMember = await streamService.isMember(attachment.streamId, userId)
      if (!isMember) {
        return res.status(403).json({ error: "Access denied" })
      }

      const url = await attachmentService.getDownloadUrl(attachment)
      res.json({ url, expiresIn: 900 })
    },

    async delete(req: Request, res: Response) {
      const userId = req.userId!
      const workspaceId = req.workspaceId!
      const { attachmentId } = req.params

      const attachment = await attachmentService.getById(attachmentId)
      if (!attachment || attachment.workspaceId !== workspaceId) {
        return res.status(404).json({ error: "Attachment not found" })
      }

      // Only allow deletion of unattached files
      if (attachment.messageId) {
        return res.status(403).json({ error: "Cannot delete attached files" })
      }

      // Validate user has access to the stream
      const isMember = await streamService.isMember(attachment.streamId, userId)
      if (!isMember) {
        return res.status(403).json({ error: "Access denied" })
      }

      await attachmentService.delete(attachmentId)
      res.status(204).send()
    },
  }
}

-- Distributed cron scheduling system
-- See docs/distributed-cron-design.md for full design documentation

-- Cron schedule definitions
-- One row per scheduled job (e.g., memo batch check every 30s)
CREATE TABLE cron_schedules (
    id TEXT PRIMARY KEY,                    -- cron_<ulid>
    queue_name TEXT NOT NULL,               -- Which queue to send to
    interval_seconds INTEGER NOT NULL,      -- How often to run
    payload JSONB NOT NULL,                 -- Data to send

    -- For workspace-specific crons (future)
    workspace_id TEXT,                      -- NULL = system-wide

    -- When the next tick needs to be created (NOT when to execute)
    -- Schedule Manager queries this to find schedules needing tick generation
    -- Updated after creating each tick: next_tick_needed_at = execute_at
    next_tick_needed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

    enabled BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- One active schedule per (queue, workspace) pair
CREATE UNIQUE INDEX idx_cron_schedules_queue_workspace
    ON cron_schedules (queue_name, workspace_id)
    WHERE enabled = true;

-- Hot path: Find schedules that need tick generation soon
-- Only scans schedules whose next tick is due in the near future
-- Prevents scanning all schedules on every Schedule Manager run
CREATE INDEX idx_cron_schedules_next_tick
    ON cron_schedules (next_tick_needed_at)
    WHERE enabled = true;


-- Cron tick coordination table
-- Ephemeral tokens representing "right to execute this schedule now"
-- Pre-generated by Schedule Manager, executed by Message Ticker
CREATE TABLE cron_ticks (
    id TEXT PRIMARY KEY,                    -- tick_<ulid>
    schedule_id TEXT NOT NULL,              -- References cron_schedules.id
    queue_name TEXT NOT NULL,               -- Denormalized for efficiency
    payload JSONB NOT NULL,                 -- Denormalized for efficiency
    workspace_id TEXT,                      -- Denormalized for efficiency

    -- When this tick should execute (NOT when created)
    -- Schedule Manager pre-generates ticks with future execute_at
    -- Message Ticker finds ticks where execute_at <= NOW()
    execute_at TIMESTAMPTZ NOT NULL,

    -- Time-based lease (same pattern as queue_tokens)
    -- NULL = available, non-NULL = being executed
    leased_at TIMESTAMPTZ,
    leased_by TEXT,                         -- ticker_<ulid> identifier
    leased_until TIMESTAMPTZ,               -- Lock expires after this

    created_at TIMESTAMPTZ NOT NULL,

    -- CRITICAL: Prevent duplicate tick generation
    -- Schedule Manager runs on multiple workers - this ensures only one tick per execution
    CONSTRAINT unique_schedule_execution UNIQUE (schedule_id, execute_at)
);

-- Hot path: Find ticks ready for execution
-- Used by Message Ticker to find ticks that are due and available
CREATE INDEX idx_cron_ticks_execute
    ON cron_ticks (execute_at)
    WHERE leased_until IS NULL OR leased_until < NOW();

-- Find ticks by schedule (for deduplication check)
CREATE INDEX idx_cron_ticks_schedule
    ON cron_ticks (schedule_id, execute_at);

-- Cleanup expired ticks (ticks that failed and lease expired)
CREATE INDEX idx_cron_ticks_cleanup
    ON cron_ticks (leased_until)
    WHERE leased_until IS NOT NULL;

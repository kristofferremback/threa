import type { Request, Response } from "express"
import type { AttachmentService } from "./service"
import type { StreamService } from "../streams"
import { isAttachmentSafeForSharing, safetyStatusBlockReason } from "./upload-safety-policy"

interface Dependencies {
  attachmentService: AttachmentService
  streamService: StreamService
}

export function createAttachmentHandlers({ attachmentService, streamService }: Dependencies) {
  return {
    /**
     * Upload a file to the workspace.
     * Files are uploaded to workspace-level (no stream) and attached to a stream when linked to a message.
     * Workspace membership is checked by middleware.
     */
    async upload(req: Request, res: Response) {
      const memberId = req.member!.id
      const workspaceId = req.workspaceId!

      // File was uploaded to S3 by multer-s3 middleware
      const file = req.file
      if (!file || !file.key) {
        return res.status(400).json({ error: "No file provided" })
      }

      // The attachment ID was generated by the upload middleware
      const attachmentId = req.attachmentId!

      const attachment = await attachmentService.create({
        id: attachmentId,
        workspaceId,
        uploadedBy: memberId,
        filename: file.originalname,
        mimeType: file.mimetype,
        sizeBytes: file.size,
        storagePath: file.key,
      })

      if (!isAttachmentSafeForSharing(attachment.safetyStatus)) {
        return res.status(400).json({ error: safetyStatusBlockReason(attachment.safetyStatus) })
      }

      res.status(201).json({ attachment })
    },

    /**
     * Get a presigned download URL for an attachment.
     * For attached files, checks stream membership.
     * For pending files (not yet attached), workspace membership is sufficient.
     */
    async getDownloadUrl(req: Request, res: Response) {
      const memberId = req.member!.id
      const workspaceId = req.workspaceId!
      const { attachmentId } = req.params

      const attachment = await attachmentService.getById(attachmentId)
      if (!attachment || attachment.workspaceId !== workspaceId) {
        return res.status(404).json({ error: "Attachment not found" })
      }

      if (!isAttachmentSafeForSharing(attachment.safetyStatus)) {
        return res.status(403).json({ error: safetyStatusBlockReason(attachment.safetyStatus) })
      }

      // For attached files, verify stream membership
      // Pending files (no stream) are accessible to any workspace member
      if (attachment.streamId) {
        const isMember = await streamService.isMember(attachment.streamId, memberId)
        if (!isMember) {
          return res.status(403).json({ error: "Access denied" })
        }
      }

      const url = await attachmentService.getDownloadUrl(attachment)
      res.json({ url, expiresIn: 900 })
    },

    /**
     * Delete an unattached file.
     * Only the user who uploaded the file can delete it.
     * Attached files cannot be deleted.
     */
    async delete(req: Request, res: Response) {
      const memberId = req.member!.id
      const workspaceId = req.workspaceId!
      const { attachmentId } = req.params

      const attachment = await attachmentService.getById(attachmentId)
      if (!attachment || attachment.workspaceId !== workspaceId) {
        return res.status(404).json({ error: "Attachment not found" })
      }

      // Only allow deletion of unattached files
      if (attachment.messageId) {
        return res.status(403).json({ error: "Cannot delete attached files" })
      }

      // Only the uploader can delete their own pending files
      if (attachment.uploadedBy && attachment.uploadedBy !== memberId) {
        return res.status(403).json({ error: "Cannot delete files uploaded by other users" })
      }

      await attachmentService.delete(attachmentId)
      res.status(204).send()
    },
  }
}

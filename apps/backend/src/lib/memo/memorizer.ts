import { z } from "zod"
import type { PoolClient } from "pg"
import type { AI } from "../ai/ai"
import { MessageFormatter } from "../ai/message-formatter"
import type { Message } from "../../repositories/message-repository"
import type { Memo } from "../../repositories/memo-repository"

/**
 * Content generated by the memorizer.
 * Following GAM paper: self-contained abstracts that can stand alone.
 */
export interface MemoContent {
  title: string
  abstract: string
  keyPoints: string[]
  tags: string[]
  sourceMessageIds: string[]
}

/**
 * Context for memorization.
 * Includes prior abstracts for vocabulary consistency.
 */
export interface MemorizerContext {
  memoryContext: string[]
  content: Message | Message[]
  existingMemo?: Memo
  existingTags?: string[]
  /** Workspace ID for cost tracking - required for cost attribution */
  workspaceId: string
}

const memoContentSchema = z.object({
  title: z.string().max(100).describe("Concise title summarizing the memo (max 100 characters)"),
  abstract: z.string().describe("Self-contained 1-2 paragraph summary preserving ALL important information"),
  keyPoints: z.array(z.string()).max(5).describe("Up to 5 key points extracted from the content"),
  tags: z.array(z.string()).max(5).describe("Up to 5 relevant tags for categorization"),
  sourceMessageIds: z.array(z.string()).describe("IDs of messages that contain the key information"),
})

const SYSTEM_PROMPT = `You are a knowledge preservation specialist for a team chat application. You create concise, self-contained memos that capture valuable information from conversations.

Your memos should:
1. Be SELF-CONTAINED - a reader should understand the memo without seeing the original messages
2. Preserve ALL important information - decisions, rationale, context, participants
3. Be FACTUAL - no meta-commentary like "this memo captures..." or "the team discussed..."
4. Use consistent vocabulary with prior memos when similar concepts appear

The abstract should be 1-2 paragraphs that could stand alone as organizational memory.

Output ONLY valid JSON matching the schema.`

const MESSAGE_MEMO_PROMPT = `Create a memo for this standalone message.

## Memory Context (prior memos for vocabulary consistency)
{{MEMORY_CONTEXT}}

## Message to Memorize
ID: {{MESSAGE_ID}}
From: {{AUTHOR_TYPE}}
Content:
{{CONTENT}}

{{EXISTING_TAGS_SECTION}}

Create a self-contained memo that preserves this knowledge.`

const CONVERSATION_MEMO_PROMPT = `Create a memo for this conversation.

## Memory Context (prior memos for vocabulary consistency)
{{MEMORY_CONTEXT}}

## Conversation Messages
{{MESSAGES}}

{{EXISTING_TAGS_SECTION}}

Create a self-contained memo that captures the key knowledge from this conversation.
In sourceMessageIds, include ONLY the message IDs that contain the most important information.`

const REVISION_PROMPT = `Revise the existing memo based on new conversation content.

## Memory Context (prior memos for vocabulary consistency)
{{MEMORY_CONTEXT}}

## Existing Memo
Title: {{MEMO_TITLE}}
Abstract: {{MEMO_ABSTRACT}}
Key Points:
{{MEMO_KEY_POINTS}}

## Updated Conversation
{{MESSAGES}}

{{EXISTING_TAGS_SECTION}}

Create an updated memo that incorporates the new information while preserving existing valuable content.`

const EXISTING_TAGS_TEMPLATE = `## Existing Tags in Workspace
Prefer these tags when applicable, but create new ones if needed:
{{TAGS}}`

export class Memorizer {
  constructor(
    private ai: AI,
    private modelId: string,
    private messageFormatter: MessageFormatter
  ) {}

  async memorizeMessage(context: MemorizerContext): Promise<MemoContent> {
    const message = context.content as Message

    const memoryContextText =
      context.memoryContext.length > 0
        ? context.memoryContext.map((a, i) => `${i + 1}. ${a}`).join("\n")
        : "No prior memos in this stream yet."

    const existingTagsSection = context.existingTags?.length
      ? EXISTING_TAGS_TEMPLATE.replace("{{TAGS}}", context.existingTags.join(", "))
      : ""

    const prompt = MESSAGE_MEMO_PROMPT.replace("{{MEMORY_CONTEXT}}", memoryContextText)
      .replace("{{MESSAGE_ID}}", message.id)
      .replace("{{AUTHOR_TYPE}}", message.authorType)
      .replace("{{CONTENT}}", message.content)
      .replace("{{EXISTING_TAGS_SECTION}}", existingTagsSection)

    const { value } = await this.ai.generateObject({
      model: this.modelId,
      schema: memoContentSchema,
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: prompt },
      ],
      temperature: 0.3,
      telemetry: {
        functionId: "memorize-message",
        metadata: { messageId: message.id },
      },
      context: { workspaceId: context.workspaceId, origin: "system" },
    })

    return {
      title: value.title,
      abstract: value.abstract,
      keyPoints: value.keyPoints,
      tags: value.tags,
      sourceMessageIds: [message.id],
    }
  }

  async memorizeConversation(client: PoolClient, context: MemorizerContext): Promise<MemoContent> {
    const messages = context.content as Message[]

    const memoryContextText =
      context.memoryContext.length > 0
        ? context.memoryContext.map((a, i) => `${i + 1}. ${a}`).join("\n")
        : "No prior memos in this stream yet."

    const messagesText = await this.messageFormatter.formatMessagesInline(client, messages, { includeIds: true })

    const existingTagsSection = context.existingTags?.length
      ? EXISTING_TAGS_TEMPLATE.replace("{{TAGS}}", context.existingTags.join(", "))
      : ""

    const prompt = CONVERSATION_MEMO_PROMPT.replace("{{MEMORY_CONTEXT}}", memoryContextText)
      .replace("{{MESSAGES}}", messagesText)
      .replace("{{EXISTING_TAGS_SECTION}}", existingTagsSection)

    const { value } = await this.ai.generateObject({
      model: this.modelId,
      schema: memoContentSchema,
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: prompt },
      ],
      temperature: 0.3,
      telemetry: {
        functionId: "memorize-conversation",
        metadata: { messageCount: messages.length },
      },
      context: { workspaceId: context.workspaceId, origin: "system" },
    })

    const validSourceIds = value.sourceMessageIds.filter((id) => messages.some((m) => m.id === id))

    return {
      title: value.title,
      abstract: value.abstract,
      keyPoints: value.keyPoints,
      tags: value.tags,
      sourceMessageIds: validSourceIds.length > 0 ? validSourceIds : messages.map((m) => m.id),
    }
  }

  async reviseMemo(client: PoolClient, context: MemorizerContext): Promise<MemoContent> {
    const messages = context.content as Message[]
    const existingMemo = context.existingMemo!

    const memoryContextText =
      context.memoryContext.length > 0
        ? context.memoryContext.map((a, i) => `${i + 1}. ${a}`).join("\n")
        : "No prior memos in this stream yet."

    const messagesText = await this.messageFormatter.formatMessagesInline(client, messages, { includeIds: true })

    const keyPointsText = existingMemo.keyPoints.map((kp, i) => `${i + 1}. ${kp}`).join("\n")

    const existingTagsSection = context.existingTags?.length
      ? EXISTING_TAGS_TEMPLATE.replace("{{TAGS}}", context.existingTags.join(", "))
      : ""

    const prompt = REVISION_PROMPT.replace("{{MEMORY_CONTEXT}}", memoryContextText)
      .replace("{{MEMO_TITLE}}", existingMemo.title)
      .replace("{{MEMO_ABSTRACT}}", existingMemo.abstract)
      .replace("{{MEMO_KEY_POINTS}}", keyPointsText)
      .replace("{{MESSAGES}}", messagesText)
      .replace("{{EXISTING_TAGS_SECTION}}", existingTagsSection)

    const { value } = await this.ai.generateObject({
      model: this.modelId,
      schema: memoContentSchema,
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        { role: "user", content: prompt },
      ],
      temperature: 0.3,
      telemetry: {
        functionId: "revise-memo",
        metadata: {
          memoId: existingMemo.id,
          messageCount: messages.length,
        },
      },
      context: { workspaceId: context.workspaceId, origin: "system" },
    })

    const validSourceIds = value.sourceMessageIds.filter((id) => messages.some((m) => m.id === id))

    return {
      title: value.title,
      abstract: value.abstract,
      keyPoints: value.keyPoints,
      tags: value.tags,
      sourceMessageIds: validSourceIds.length > 0 ? validSourceIds : messages.map((m) => m.id),
    }
  }
}

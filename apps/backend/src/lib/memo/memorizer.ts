import type { AI } from "../ai/ai"
import { MessageFormatter } from "../ai/message-formatter"
import type { Message } from "../../repositories/message-repository"
import type { Memo } from "../../repositories/memo-repository"
import {
  memoContentSchema,
  getMemorizerSystemPrompt,
  MEMORIZER_MESSAGE_PROMPT,
  MEMORIZER_CONVERSATION_PROMPT,
  MEMORIZER_REVISION_PROMPT,
  MEMORIZER_EXISTING_TAGS_TEMPLATE,
  MEMO_TEMPERATURES,
} from "./config"

/**
 * Content generated by the memorizer.
 * Following GAM paper: self-contained abstracts that can stand alone.
 */
export interface MemoContent {
  title: string
  abstract: string
  keyPoints: string[]
  tags: string[]
  sourceMessageIds: string[]
}

/**
 * Context for memorization.
 * Includes prior abstracts for vocabulary consistency.
 */
export interface MemorizerContext {
  memoryContext: string[]
  content: Message | Message[]
  existingMemo?: Memo
  existingTags?: string[]
  /** Workspace ID for cost tracking - required for cost attribution */
  workspaceId: string
  /** Author's timezone for date anchoring (IANA identifier, e.g., "America/New_York") */
  authorTimezone?: string
}

export class Memorizer {
  constructor(
    private ai: AI,
    private modelId: string,
    private messageFormatter: MessageFormatter
  ) {}

  async memorizeMessage(context: MemorizerContext): Promise<MemoContent> {
    const message = context.content as Message

    const memoryContextText =
      context.memoryContext.length > 0
        ? context.memoryContext.map((a, i) => `${i + 1}. ${a}`).join("\n")
        : "No prior memos in this stream yet."

    const existingTagsSection = context.existingTags?.length
      ? MEMORIZER_EXISTING_TAGS_TEMPLATE.replace("{{TAGS}}", context.existingTags.join(", "))
      : ""

    const prompt = MEMORIZER_MESSAGE_PROMPT.replace("{{MEMORY_CONTEXT}}", memoryContextText)
      .replace("{{MESSAGE_ID}}", message.id)
      .replace("{{AUTHOR_TYPE}}", message.authorType)
      .replace("{{CONTENT}}", message.contentMarkdown)
      .replace("{{EXISTING_TAGS_SECTION}}", existingTagsSection)

    const { value } = await this.ai.generateObject({
      model: this.modelId,
      schema: memoContentSchema,
      messages: [
        { role: "system", content: getMemorizerSystemPrompt(context.authorTimezone) },
        { role: "user", content: prompt },
      ],
      temperature: MEMO_TEMPERATURES.memorization,
      telemetry: {
        functionId: "memorize-message",
        metadata: { messageId: message.id },
      },
      context: { workspaceId: context.workspaceId, origin: "system" },
    })

    return {
      title: value.title,
      abstract: value.abstract,
      keyPoints: value.keyPoints,
      tags: value.tags,
      sourceMessageIds: [message.id],
    }
  }

  async memorizeConversation(formattedMessages: string, context: MemorizerContext): Promise<MemoContent> {
    const messages = context.content as Message[]

    const memoryContextText =
      context.memoryContext.length > 0
        ? context.memoryContext.map((a, i) => `${i + 1}. ${a}`).join("\n")
        : "No prior memos in this stream yet."

    const existingTagsSection = context.existingTags?.length
      ? MEMORIZER_EXISTING_TAGS_TEMPLATE.replace("{{TAGS}}", context.existingTags.join(", "))
      : ""

    const messageCount = formattedMessages.split("<message").length - 1

    const prompt = MEMORIZER_CONVERSATION_PROMPT.replace("{{MEMORY_CONTEXT}}", memoryContextText)
      .replace("{{MESSAGES}}", formattedMessages)
      .replace("{{EXISTING_TAGS_SECTION}}", existingTagsSection)

    const { value } = await this.ai.generateObject({
      model: this.modelId,
      schema: memoContentSchema,
      messages: [
        { role: "system", content: getMemorizerSystemPrompt(context.authorTimezone) },
        { role: "user", content: prompt },
      ],
      temperature: MEMO_TEMPERATURES.memorization,
      telemetry: {
        functionId: "memorize-conversation",
        metadata: { messageCount },
      },
      context: { workspaceId: context.workspaceId, origin: "system" },
    })

    const validSourceIds = value.sourceMessageIds.filter((id) => messages.some((m) => m.id === id))

    return {
      title: value.title,
      abstract: value.abstract,
      keyPoints: value.keyPoints,
      tags: value.tags,
      sourceMessageIds: validSourceIds.length > 0 ? validSourceIds : messages.map((m) => m.id),
    }
  }

  async reviseMemo(formattedMessages: string, context: MemorizerContext): Promise<MemoContent> {
    const messages = context.content as Message[]
    const existingMemo = context.existingMemo!

    const memoryContextText =
      context.memoryContext.length > 0
        ? context.memoryContext.map((a, i) => `${i + 1}. ${a}`).join("\n")
        : "No prior memos in this stream yet."

    const keyPointsText = existingMemo.keyPoints.map((kp, i) => `${i + 1}. ${kp}`).join("\n")

    const existingTagsSection = context.existingTags?.length
      ? MEMORIZER_EXISTING_TAGS_TEMPLATE.replace("{{TAGS}}", context.existingTags.join(", "))
      : ""

    const messageCount = formattedMessages.split("<message").length - 1

    const prompt = MEMORIZER_REVISION_PROMPT.replace("{{MEMORY_CONTEXT}}", memoryContextText)
      .replace("{{MEMO_TITLE}}", existingMemo.title)
      .replace("{{MEMO_ABSTRACT}}", existingMemo.abstract)
      .replace("{{MEMO_KEY_POINTS}}", keyPointsText)
      .replace("{{MESSAGES}}", formattedMessages)
      .replace("{{EXISTING_TAGS_SECTION}}", existingTagsSection)

    const { value } = await this.ai.generateObject({
      model: this.modelId,
      schema: memoContentSchema,
      messages: [
        { role: "system", content: getMemorizerSystemPrompt(context.authorTimezone) },
        { role: "user", content: prompt },
      ],
      temperature: MEMO_TEMPERATURES.memorization,
      telemetry: {
        functionId: "revise-memo",
        metadata: {
          memoId: existingMemo.id,
          messageCount,
        },
      },
      context: { workspaceId: context.workspaceId, origin: "system" },
    })

    const validSourceIds = value.sourceMessageIds.filter((id) => messages.some((m) => m.id === id))

    return {
      title: value.title,
      abstract: value.abstract,
      keyPoints: value.keyPoints,
      tags: value.tags,
      sourceMessageIds: validSourceIds.length > 0 ? validSourceIds : messages.map((m) => m.id),
    }
  }
}
